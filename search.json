[{"title":"写个脚本保护视力","url":"/Whim/create-my-dark-mode/","content":"\n用 JS 给网页加个深色模式保护眼睛（和一个失败的实现）。\n\n\n\n起因最近在看的一些技术文档都是用VuePress 写的，虽然很简洁好看，但是大部分网页都是白屏黑字，对于一个每天除了睡觉就是盯着电子屏幕的人来说，#fff的背景色配上黑色小字实在是太伤眼睛了。这我大JS不就派上用场了？为了保护视力，写个脚本加个深色模式吧！\n开干首先分析下页面结构，主页面是个叫page的class，侧边栏是个叫sidebar的class，那么很简单，直接用qeurySelector改改颜色就行了：\ndocument.querySelector(&quot;.page&quot;).style.backgroundColor = &#x27;#111&#x27;;document.querySelector(&quot;.page&quot;).style.color = &#x27;#ccc&#x27;;document.querySelector(&quot;.sidebar&quot;).style.backgroundColor = &#x27;#111&#x27;;\n\n改完之后的效果：\n\n\n果然舒服多了。而且由于前端路由的特性，页面变化相当于在document这个容器中装各种各样的内容，这样切换到别的页面也还是深色模式。但是技术文档的特点就是有很多行内代码块，在VuePress中颜色是#476582，深色背景下就不是很友好，比如：\n\n\n这也很简单，行内代码都是用&lt;code&gt;&lt;/code&gt;包裹的，那直接选中改色不就完了：\nconst codeList = Array.from(document.querySelectorAll(&quot;code&quot;));codeList.forEach(item =&gt; &#123;item.style.color = &quot;#54f36f&quot;;&#125;);\n\n大功告成，现在的效果是这样的：\n\n\n但是，当我们跳转到另一个页面，行内代码的颜色又变回去了🤒\n因此，新的问题就是：怎样在路由变化时也能让行内代码变为想要的颜色呢？\n根据Vue Router的两种实现方式：Hash Router和History Router，可以很容易的想到只要监听路由变化，在路由变化的时候改个颜色就行了呀！如果是Hash Router，就非常简单，直接监听hashchange事件就行了。但是很多网站为了优雅，都是使用的History Router模式（但我怀疑使用Hash Router是不是没法用锚点链接和copy link to highlight了？在自己的站点上测试了下貌似没法用）。\n复习下History Router的实现方式，主要就是利用History API：\n\n用pushState和replaceState来实现页面内容的更新和会话历史栈的更新\n用popState来监听前进后退等事件\n\npushState和replaceState是相辅相成的，前者记录历史，后者切换url，这样点击浏览器的前进后退时也能滚动到锚点位置，而且有好看的滚动动画。那么监听哪个事件呢？\n从使用场景上来想，如果是在一个文档中有不同的标题，那么进入文档时，首先进行pushState记录历史（url），然后使用replaceState定位到当前的锚点链接（标题），在滑动浏览的过程中，不断使用replaceState来更新当前的锚点链接，而直接点击某个小标题时，则使用pushState保证回退时可以回退到正确位置。这样看来应该是使用pushState执行的次数会少一些。\n接下来就开始实现了。由于个人使用，不用考虑兼容性什么的问题（日常用IE那是不可能的），直接用ES6的proxy做代理即可：\nhistory.pushState = new Proxy(history.pushState, &#123;    apply: function (target, thisBinding, args) &#123;        const codeList = Array.from(document.querySelectorAll(&quot;code&quot;));        if(codeList[0].style.color !== &quot;rgb(84, 243, 111)&quot;) &#123;            codeList.forEach(item =&gt; &#123;item.style= &quot;color: #54f36f&quot;;&#125;);        &#125;        return target.apply(thisBinding, args);    &#125;,&#125;);\n\n判断是为了减少反复更改的次数。不过这么写还有一个问题，就是如果从侧边栏进入到另一个文档，第一次视图不会更新。这个问题不知道该怎么解决，我目前的做法是手动再push一遍，如下：\nhistory.pushState = new Proxy(history.pushState, &#123;    apply: function (target, thisBinding, args) &#123;        const codeList = Array.from(document.querySelectorAll(&quot;code&quot;));        if(codeList[0].style.color !== &quot;rgb(84, 243, 111)&quot;) &#123;            codeList.forEach(item =&gt; &#123;item.style= &quot;color: #54f36f&quot;;&#125;);        &#125;        window.pushState(window.location.href)\t\t// 加上这一句        return target.apply(thisBinding, args);    &#125;,&#125;);\n\n这样会导致得回退两次才能退回去，且加载时会有一闪而过的白屏。\n接着给window添加一个onload事件，让第一次进入页面时代码就亮起来：\nwindow.onload = function() &#123;     const codeList = Array.from(document.querySelectorAll(&quot;code&quot;));            codeList.forEach(item =&gt; &#123;item.style.color = &quot;#54f36f&quot;;&#125;);&#125;\n\n最后是侧边栏，不过我觉得侧边栏不是很有必要，稍微写一下：\nArray.from(document.querySelectorAll(&quot;.sidebar-link:not(.sidebar-link.active)&quot;)).forEach(item =&gt; &#123;item.style.color=&quot;#aaaaaa&quot;&#125;)\n\n最终效果：\n\n\n最后为了保护眼睛折腾了好半天，最后实现的效果还不尽如人意，健康真费劲啊。从结果上说，可能看屏幕一小时就出去晒晒太阳是更经济的选择。不过借这个突发奇想复习了下history router，也挺好的。\n","categories":["Whim"],"tags":["技术随笔","History Router"]},{"title":"Vue + NodeJS + MySQL 搭建文章后台管理系统","url":"/Projects/article-admin/","content":"\n功能、目录结构、设计说明和一些小细节。\n\n\n\n概览Article Admin 是一个前后端分离的文章/博客管理系统。前端采用Vue2.x并结合ElementUI，后端使用Node.js的Express框架，数据库为MySQL8.0。\n本项目是HITSZ 21春数据库系统课程实验四的作品。\n\n在线demo怕被攻击就不放出了🤐\n\nrepository: [github]WoodenStone/article_admin\nSETUP克隆项目git clone https://github.com/WoodenStone/article_admin.git\n\n数据库将articleAdmin.sql导入MySQL即可生成数据库。\n\n ⭕由于存在同一张表上存在多个触发器的情况，MySQL版本不能低于5.7。\n\n后端# 进入项目目录cd article_admin/node_back_end# 安装依赖npm install# 启动项目node app.js\n\n注意：需要修改数据库用户名、密码。\n前端# 进入项目目录cd article_admin/vue_front_end# 安装依赖npm install# 启动项目npm run dev\n\n访问 http://localhost:9529 查看前端界面。\n部署数据库：\n安装不低于5.7版本的MySQL，并导入articleAdmin.sql执行建表。\n前端：\n根据需要配置生产环境的路径，然后运行：\n# 生成静态文件npm run build\n\n将/dist目录下的文件放在服务器可访问路径下（如/www）。\n后端：\n修改/src/sql/db.js中的数据库配置，修改/app.js中的图片上传路径。\n使用pm2或forever等工具启动项目，保持后端为开启状态。\n最后修改nginx配置，通过ip或域名访问查看效果。\n预览\n\n\n\n\n\n\n主要功能- 注册- 登录 / 注销- 用户信息更改- 文章管理\t- 发布文章\t- 删除文章\t- 编辑文章\t- 模糊搜索\t- 点赞\t- 收藏到特定收藏夹\t- Markdown编辑器及图片插入\t- 文章标签\t- 按特定方式排序（时间倒序、赞数降序、评论数降序、收藏数降序）- 评论回复\t- 评论文章\t- 回复用户\t- 查看个人收到的评论、回复\t- 收藏夹\t- 添加 / 删除收藏夹\t- 更改收藏夹名及描述\t- 内部文章查看、删除、移动- 用户关注\t- 关注和取关- 站内信\t- 收 / 发站内信\t- 阅读状态标记\t- 输入错误地址时重定向至404\n\n\n\n目录结构.|-- node_back_end\t\t# 后端工程文件|   |-- app.js\t\t\t# 主要API|   |-- package-lock.json|   |-- package.json\t\t# 配置文件|   |-- public\t\t\t# 静态目录|   |-- src\t\t\t# 数据库相关操作|   |-- upload\t\t\t# 上传图片存放|-- vue_front_end\t\t# 前端工程文件    |-- babel.config.js    |-- package-lock.json    |-- package.json\t\t# 项目配置    |-- public\t\t\t# html模板和网站图标    |   |-- favicon.ico    |   |-- index.html    |-- src\t\t\t# 主要代码    |   |-- App.vue    |   |-- assets\t\t# 静态资源，如图标字体等    |   |-- components\t\t# 公用组件    |   |   |-- ArticleList\t# 文章列表组件    |   |   |-- BreadCrumb\t# 导航栏面包屑    |   |   |-- Collection\t# 收藏夹组件    |   |   |-- Comment\t\t# 评论、回复组件    |   |   |-- Message\t\t# 站内信（私信）组件    |   |   |-- Tags\t\t# 文章标签组件    |   |-- layout\t\t# 页面基础布局    |   |-- main.js\t\t# 入口文件 加载组件等    |   |-- plugins\t\t# 引入的插件    |   |-- router\t\t# 路由    |   |-- settings.js    |   |-- store\t\t# 全局store管理    |   |-- styles\t\t# 全局样式    |   |-- utils\t\t# 常用方法    |   |-- views\t\t# 各页面    |       |-- error-page\t# 404页面    |       |-- form\t\t# 表单 实现文章修改和创建    |       |-- home\t\t# 站点主页面    |       |-- login\t\t# 登录、注册    |       |-- table    |       |   |-- detail.vue\t# 文章详情    |       |   |-- index.vue\t# 文章列表    |       |-- user\t\t# 用户相关页面    |           |-- change.vue\t\t\t# 修改用户信息    |           |-- collection.vue\t\t# 收藏夹    |           |-- components    |           |   |-- UserInfo.vue\t\t# 用户信息主页面    |           |-- favorite.vue\t\t# 收藏的文章    |           |-- index.vue\t\t\t# 路由入口    |           |-- message.vue\t\t\t# 站内信页面    |           |-- visitor.vue\t\t\t# 访客界面    |-- vue.config.js\t\t# vue-cli配置\n\n设计详细说明数据库概览数据库设计共包含8个实体，14个联系。\n\n努力地想让数据库满足第三范式……\n\nER图：\n\n\n补充说明\ncomments - 评论回复表\n\n对于评论表，数据库字段如下：\ncomment_id | publisher_id | recipient_id | article_commented_id | content | create_time | is_reply | comment_index\n\ncomment_id 为主键，标识某条评论或回复的唯一 ID。 \npublisher_id，recipient_id 和 article_commented_id 均为外键，分别对应 user_info 用户信息表中的 user_id、user_id 和 article 文章信息表中的 id， 表示发布者 id，接收方 id 和被评论文章的 id。 \n其 中 comment_id 、 publisher_id 、 article_commented_id 、 content 和 create_time 均不能为空，表示需要唯一确定某篇文章下由某个用户所发表的某条评论。而 recipient_id 可以为空，因为如果用户直接对某篇文章发表回复，就不需要特意指定接收者 ID(即文章作者 ID)；相应地，如果不为空，则需要在 is_reply 中指定为 1，并且指定接收者 ID 和该评论在该文章中的索引。comment_index 字段的设置是由于一个用户可能在某篇 文章下发表多条评论，直接查找 comment_id 过于繁琐，因此显式指定其文章内索引。下面是 api 接口返回的一个实例：\n[  &#123;    &quot;comment_id&quot;: 35,    &quot;publisher_id&quot;: 1,    &quot;recipient_id&quot;: null,    &quot;article_commented_id&quot;: 20,    &quot;content&quot;: &quot;月が綺麗ですね&quot;,    &quot;create_time&quot;: &quot;2021-11-22T12:54:36.000Z&quot;,    &quot;is_reply&quot;: null,    &quot;comment_index&quot;: 0,    &quot;children&quot;: [      &#123;        &quot;comment_id&quot;: 36,        &quot;publisher_id&quot;: 1,        &quot;recipient_id&quot;: 1,        &quot;article_commented_id&quot;: 20,        &quot;content&quot;: &quot;月が綺麗ですね&quot;,        &quot;create_time&quot;: &quot;2021-11-22T12:54:40.000Z&quot;,        &quot;is_reply&quot;: 1,        &quot;comment_index&quot;: 0,        &quot;publisher_name&quot;: &quot;admin&quot;,        &quot;recipient_name&quot;: &quot;admin&quot;      &#125;    ],    &quot;publisher_name&quot;: &quot;admin&quot;  &#125;]\n\n\n\n后端后端没有完整的架构，仅提供RESTful API用于操作数据库，以便增删查改。\nAPI均以/api/前缀，并在注释简要说明了所提供的功能，主要包括：\n\n\n\n名称\n方法\n简要功能\n\n\n\nLogin\nPOST\n用户登录\n\n\nRegister\nPOST\n用户注册\n\n\nuserInfoChange\nPOST\n用户信息更改\n\n\nuploadAvatar\nPOST\n头像上传\n\n\nArticle\nGET\n获取带有标签的文章列表\n\n\npersonalArticle\nGET\n获取某用户的文章\n\n\narticleDetail\nGET\n获取某篇文章信息及标签\n\n\ndeleteArticle\nDELETE\n删除某一篇文章\n\n\naddArticle\nPOST\n添加文章\n\n\nupdateArticle\nPOST\n更新某一篇文章\n\n\nimgUpload\nPOST\n文章内图片上传\n\n\ngetAvatar\nGET\n由用户ID获取用户头像\n\n\ngetAvatarByName\nGET\n由name获取头像\n\n\ngetIdByName\nGET\n由用户名获取id\n\n\nthumbupStatus\nGET\n获取用户对某篇文章的点赞状态\n\n\nfavoriteStatus\nGET\n获取用户对某篇文章的收藏状态\n\n\nthumbupStatus\nPOST\n变更点赞状态\n\n\nfavoriteStatus\nPOST\n变更收藏状态\n\n\ngetRelationStatusOne\nGET\n获取一对一关注状态\n\n\nfollowStatusChange\nPOST\n变更关注状态\n\n\ngetFollowerNumber\nGET\n获取被关注数\n\n\ngetFollowingNumber\nGET\n获取关注数\n\n\ncommentsOfOneArticle\nGET\n获取某篇文章的评论和回复\n\n\nComment\nPOST\n添加文章评论或回复\n\n\nFollowersList\nGET\n获取被关注列表\n\n\nFollowingList\nGET\n获取关注人列表\n\n\nCommentsReceived\nGET\n某用户收到的评论和回复\n\n\ndirectMessage\nGET\n获取某用户收到的站内信\n\n\ndirectMessageOut\nGET\n获取某用户发出的站内信\n\n\nmessageReadStatus\nPOST\n更改某条站内信的阅读状态\n\n\nnewMessage\nPOST\n发送站内信\n\n\nmessage\nDELETE\n删除某条站内信\n\n\ncollection\nGET\n获取某用户的收藏夹\n\n\nfavoriteArticle\nGET\n获取某用户某收藏夹的文章\n\n\nnewCollection\nPOST\n创建新收藏夹\n\n\ncollectionInfo\nPOST\n修改收藏夹信息\n\n\ncollection\nDELETE\n删除收藏夹\n\n\ncollectionStatus\nGET\n查找某用户将某篇文章收藏于哪些收藏夹\n\n\narticleFavorite\nPOST\n添加某篇文章到某些收藏夹\n\n\nArticleThumbupDesc\nGET\n获取赞数降序的文章列表\n\n\nArticleFavoriteDesc\nGET\n获取收藏降序的文章列表\n\n\nArticleCommentsDesc\nGET\n获取回复评论数降序的文章列表\n\n\nsearch\nPOST\n模糊搜索，包含标题、内容、作者\n\n\nsearchName\nPOST\n用户名输入提示\n\n\nstatistic\nGET\n首页创作统计数据\n\n\n补充说明文章标签由于文章和标签是多对多关系，故数据库设计将文章标签id和文章id单独抽取出来组成一个描述映射的关系，而文章表（article）和标签表(tag)独立存在。这就给修改标签带来了麻烦。\n在更新文章时，每个标签都可能被更改、删除，因此采用的方式是在先删除该文章原有的标签映射（article_tag表），再进行标签表（tag）的更新，最后重新建立该文章和标签的映射（article_tag表）。这个流程是：\ndelete tag mappings -&gt; add tags -&gt; add tag mappings \n\n可能效率比较低，或许后续能找到更好的方式。\n图片上传图片上传采用了multer中间件，用到的地方有用户头像上传和文章内图片上传。主要思路都是：\n\n将图片上传至服务器\n将服务器路径存入数据库\n将服务器路径返回，前端回显\n\n具体的操作有细微不同，且需要进行静态资源路径的设置。\n评论和回复评论和回复的sql逻辑不太明显，因为数据库表字段的设计造成了一些麻烦。\n两个主要的功能：①查询某篇文章下的评论回复和②查询某用户收到的评论回复。\n\n查询某篇文章下的评论回复\n\n由于需要返回的是一个最多2层高的树，示例如：\n- 评论1\t- 回复1\t- 回复2- 评论2\t- 回复1\t- 回复2- 评论3\n\n故采取的方式是先找到该文章下的所有评论，得到一个包含全部评论id的数组，再依次查找每条评论下是否有存在回复，如果存在回复，就拼接到children数组中。\n在查找回复的sql中，不能指定接收者的id(即comments表中的recipient_id)，因为回复有可能是楼中楼的沟通，如：\n- A 评论[content]\t- B 回复 A \t# 回复1\t- C 回复 B\t# 回复2\t- C 回复 C\t# 回复3\n\n如果指定接收用户id，可能导致回复2和回复3都无法收取到。\n这里也比较降低效率的是需要反复地获取用户名（或者进行表的连接），因为数据库设计都是以user_id作为外键关联。\n\n查询某用户收到的评论回复\n\n以查询某用户收到的评论为例，说明一下sql的逻辑。\n首先，要在article表中找到该用户所发表的文章id，然后根据文章id在comments表中查询收到的评论（排除自己发表的评论），最后需要拼接上发表者用户名和文章标题。\nsql:\nSELECT ar.title,         co.publisher_name,         co.publisher_id,         co.article_commented_id,         co.content,         co.create_time,         co.is_replyFROM     (SELECT us.user_name AS publisher_name,         uc.publisher_id,         uc.article_commented_id,         uc.content,         uc.create_time,         uc.is_reply    FROM         (SELECT c.publisher_id,         c.article_commented_id,         c.content,         c.create_time,        is_reply        FROM comments c, article a, user_info u        WHERE c.article_commented_id = a.id                AND a.author_id = u.user_id                AND u.user_id = $&#123;uid&#125;                AND is_reply is null                AND publisher_id &lt;&gt; $&#123;uid&#125;) AS uc, user_info us        WHERE uc.publisher_id = us.user_id ) AS co, article ar    WHERE co.article_commented_id = ar.id;\n\n$&#123;uid&#125;是传入的参数。\n这两个功能使用db()分别返回一个Promise，最后使用Promise.all()一同处理，将得到的结果拼接，返回给前端。\n\n后端现在基本改用参数化查询了，会对双引号等做转义，并且能预防SQL注入。\n各种原理还是不太懂，不过到处在用promise、async / await，对这些更了解了。\n\n前端概览前端根据数据库设计，主要有登录注册、个人主页、文章、站内信、收藏几个主要路由，分为登录注册、文章增删查改、站内信、评论、站内信、收藏几个主要模块来实现。\n采用vue-cli脚手架搭建项目，主要使用ES6语法编写代码。使用vue-router进行路由管理，Less作为CSS预处理器，Axios进行前后端数据交互。\n补充说明登录注册第一版：登录采取的是比较简陋（不科学）的方式：用户输入用户名、密码后向服务端验证正确性，若正确则将信息存入 localStorage，权限也是写死在用户信息中的（作为数据库表中的一个字段存在）。这是考虑到作为一个博客后台管理系统，或者说带有部分社交属性（私信、评论）的系统，管理员的权限并不需要和普通用户做出非常大的区分。登录信息过期通过代码设置 localStorage 的有效期为 7 天。\n\n21/12/28 update\n注册登录现在采用了jwt做验证。具体流程是：\n\n用户第一次登录时，后端签发token，设置有效期7天\n前端拿到token存入cookie中（or localStorage），利用axios拦截器在每次发送请求时都带上这个token（这里叫aa-token）\n后端对除白名单内的路由进行token校验（白名单就是登录、注册这两个），如果校验失败，根据消息提示告诉前端是token过期了还是没有登录；否则正常处理\n如过期，前端用相应拦截器根据返回的错误状态码展示提示，并跳转到登录页；否则正常处理\n\n同时，前端还使用route.beforeEach在进入每个路由前都进行判断是否有token存在。如果token过期，不发请求应该是感受不到的。如果进行操作，就会进入到登录页。\n如果要无感保持登录，最好加上refresh token。\n由于原本的很多代码都是基于localStorage中的信息写的，为了尽可能地少改点代码（否则真的要重写了），在登录后还是会将信息存到localStorage中。不过它的过期时间已经没意义了，都由token进行外层的保护。\n还有一点修改的是头像上传由于用的是el-upload组件，因此要手动挂上请求头，返回的时候一样处理。如果恰好在头像上传的过程中token过期了，也需要在失败处理中重定向到登录页。\n\n文章列表展示文章列表的主要组件位于components/ArticleList下，实现功能为文章列表的展示，可选项包括：\n\n是否展示包含新增、搜索和排序的工具栏 - showHeader\n是否显示作者 - showAuthor\n是否展示内容预览 - showContent\n使用场景：个人文章 - personal\n使用场景：收藏夹内 - collection\n\n该组件在文章列表（路由/table）、个人收藏夹内页面（/user/favorite）、用户个人文章（包含自己的和访客所见的文章： /user/index和/user/visitor）页面均有使用。\n文章排序排序方式有：默认时间倒序、按赞数降序、按收藏数降序和按评论数降序，后三种后端返回的都是一个文章id数组，按指定方式降序排列。\n如按赞数降序返回的是一个形如[6, 9, 10, 1]的数组，表明赞数为6&gt;9&gt;10&gt;1&gt;其它，未出现的文章赞数为0（表中根本没有这篇文章被赞过的记录）。前端根据这个数组进行交换排序：\n/** * @description:: 根据传入的index索引对array进行交换排序 * @param &#123;Array&#125; index * @param &#123;Array&#125; array * @return &#123;*&#125; * @author: WoodenStone */interchange (index, array) &#123;  for (let i = 0; i &lt; index.length; i++) &#123;    if (array[i].id !== index[i].id) &#123;      let temp = &#123;&#125;      for (let j = i + 1; j &lt; array.length; j++) &#123;        if (array[j].id === index[i].id) &#123;          // 用set或者splice来更新视图          temp = array[j]          this.$set(array, j, array[i])          this.$set(array, i, temp)        &#125;      &#125;    &#125;  &#125;&#125;,\n\n\n这么写是在后端排好序返回一个大数据包和前端排序进行交换哪个更快进行了选择，不过或许哪个都不是好的选择……\n\n文章标签核心组件位于/src/components/Tags，主要实现功能为输入标签，按回车键添加标签，按DELETE键删除标签。单个标签的字数和一篇文章最多可有的标签数均作出限制。\n评论回复找了一些开源轮子，没找到满意的，最后还是自己实现一个。核心组件位于/src/components/Comment下，分为单个回复（ReplyItem）、单个评论（包含回复，CommentItem）和所有评论（CommentGroup），给index传入正确的数据即可展示，评论是最多两层的树，效果如下图：\n\n\n评论的回复采取的是ElementUI中的dialog组件实现，并使用开源轮子封装的v-dialogDrag指令使得dialog框可以拖动。在回复和评论中的“回复”按钮是在CommentGroup中组装的，换言之CommentItem和ReplyItem其实是兄弟关系。这样做是因为想把“回复”这个需要调用接口，传递数据的功能尽可能集中起来，就不用再使用$emit()等方法传参了。不过从设计上来看，可能设计为父子关系会更为直观一些。\n\n前端是越看需要改进的地方越多😑 重构❎ 重写✅\n虽然这个项目叫做“xxx后台管理系统”，但是只是为了符合“xxx后台管理系统”的叫法……从实现上来看，文章详情页、收藏、站内信都不能说很符合这个场景，更像是一个综合在一起的应用。\n最后，自己给自己提需求实在是太困难了！每当开始思考用户画像的时候，都会陷入“这种东西真的会有人想用吗”的怀疑中。从功能上来说，其实脑海里想的是lofter，但是lofter的目标群体还是挺明确的，而且它网页版和手机版差得不是一点半点，用起来感觉也怪怪的。最终还是在“既然想了就得做出来吧”这种念头的鼓励下做了。嗯，用来放点自己的零散想法还是可以的。第一个项目，之后还是想尝试点别的，RN？electron？以后再说咯。\n\n参考vue-element-admin的基础模板\n","categories":["Projects"],"tags":["vue","nodejs","MySQL"]}]